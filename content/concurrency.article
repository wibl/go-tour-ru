Многопоточность
В Go возможности для реализации многопоточности являются неотъемлемой частью языка. В этом уроке вы найдете их описание и некоторые примеры использования.

Авторы Go
https://golang.org

* Go-процедуры (goroutines)

_Go-процедура_ это легкий поток, управляемый средой выполнения Go.

	go f(x, y, z)

создает новую go-процедуру и запускает в ней

	f(x, y, z)

`f`, `x`, `y`, и `z` определяются в текущей go-процедуре, а выполнение `f` происходит в новой go-процедуре.

Go-процедуры исполняются в том же адресном пространстве, поэтому доступ к общей памяти должен быть синхронизирован. Пакет [[https://golang.org/pkg/sync/][`sync`]] предоставляет полезные примитивы, хотя они вам не понадобятся часто в Go, т.к. существуют другие. (Смотрите следующий слайд.)

.play concurrency/goroutines.go

* Каналы

Каналы это типизированные "трубы", по которым вы можете посылать и получать значения с помощью оператора `<-`.

	ch <- v    // Послать v в канал ch.
	v := <-ch  // Получить из канала ch, и
	           // присвоить значение переменной v.

(Данные перемещаются в направлении стрелки.)

Так же как карты и срезы, каналы должны быть созданы перед использованием:

	ch := make(chan int)

По умолчанию отправление и получение блокируются до тех пор, пока другая сторона не готова. Это позволят go-процедурам синхронизироваться без явного использования блокировок и условных переменных.

Данный пример суммирует числа среза, распределяя работу между go-процедурами.
Как только обе go-процедуры закончили свои вычисления, производится вычисление финального результата.

.play concurrency/channels.go

* Буферизированные каналы

Каналы могут быть _буферизированными_. Чтобы инициализировать буферизированный канал, передайте в `make` вторым параметром размер буфера:

	ch := make(chan int, 100)

Отправка в буферизованный канал блокируется, только если буфер полон. Получение блокируется, когда буфер пуст.

Измените пример, чтобы переполнить буфер, и посмотрите, что будет.

.play concurrency/buffered-channels.go

* Range и Close

Тот, кто посылает данные, может закрыть (`close`) канал, чтобы указать, что больше значений отправлено не будет. Получатели данных могут проверить, закрыт ли канал, использовав второй параметр в выражении получения: после

	v, ok := <-ch

`ok` будет `false`, если больше нет значений для получения, и канал закрыт.

Цикл `for`i`:=`range`c` получает значения из канала до тех пор, пока он не закрыт.

*Замечание:* Только отправитель данных должен закрывать канал, но никогда - получатель. Попытка отправить данные в закрытый канал вызовет panic.

*Еще замечание:* Каналы не как файлы; обычно вам не надо их закрывать. Закрывать необходимо, только когда получателю надо указать, что данных для получения больше нет, например, для завершения цикла `range`.

.play concurrency/range-and-close.go

* Select

Оператор `select` позволяет go-процедуре находиться в ожидании нескольких операций передачи данных.

`select` блокируется до тех пор, пока один из его блоков `case` не будет готов к запуску, а затем выполняет этот блок. Если сразу несколько блоков могут быть запущены, то выбирается произвольный.

.play concurrency/select.go

* Блок по умолчанию в Select

Блок `default` в `select` запускается, если никакой другой блок не готов.

Используйте `default`, чтобы посылать и получать данные без блокировок:

	select {
	case i := <-c:
		// используйте i
	default:
		// получение из c вызвало бы блокировку
	}

.play concurrency/default-selection.go

* Упражнение: равнозначные двоичные деревья

Может существовать множество различных двоичных деревьев с одинаковой последовательностью значений в листовых узлах. Например, здесь представлены два двоичных дерева хранящие последовательность 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

Функции для проверки, содержат ли два двоичных дерева одинаковую последовательность, довольно сложны в большинстве языков. Мы используем конструкции многопоточности и каналы Go, чтобы написать простое решение.

Данный пример использует пакет `tree`, который объявляет тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Продолжение на [[javascript:click('.next-page')][следующей странице]].

* Упражнение: равнозначные двоичные деревья

*1.* Реализуйте функцию `Walk`.

*2.* Протестируйте функцию `Walk`.

Функция `tree.New(k)` создает структурированное случайным образом двоичное дерево, которое содержит значения `k`, `2k`, `3k`, ..., `10k`.

Создайте новый канал `ch` и запустите обход дерева:

	go Walk(tree.New(1), ch)

Затем получите и напечатайте 10 значений из канала. Это должны быть цифры 1, 2, 3, ..., 10.

*3.* Реализуйте функцию `Same`, используя `Walk` для определения, хранят ли `t1` и `t2` одинаковые значения.

*4.* Протестируйте функцию `Same`.

`Same(tree.New(1),`tree.New(1))` должна вернуть true, а `Same(tree.New(1),`tree.New(2))` - false.

Документацию для `Tree` можно найти [[https://godoc.org/golang.org/x/tour/tree#Tree][здесь]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

Мы видели, насколько хорошо каналы подходят для связи между go-процедурами.

Но что если нам не нужна связь? Что если мы только хотим убедиться, что, во избежание конфликтов,
только одна go-процедура имеет доступ к переменной в любой момент времени?

Эта концепция известна как _взаимное_исключение_, и общепринятым названием для структуры данных, которая это позволяет, является _мьютекс_ (_mutex_).

Стандартная библиотека Go предоставляет взаимное исключение с помощью
[[https://golang.org/pkg/sync/#Mutex][`sync.Mutex`]] и двух его методов:

- `Lock`
- `Unlock`

Мы можем объявить блок кода, который будет выполняться при взаимном исключении, окружив его вызовами к `Lock` и `Unlock`,  как показано в методе `Inc`.

Мы также можем использовать `defer`, чтобы удостовериться, что мьютекс будет освобожден, как в методе `Value`.

.play concurrency/mutex-counter.go

* Упражнение: поисковый робот

В этом упражнении вы будете использовать возможности многопоточности Go для распараллеливания поискового робота.

Измените функцию `Crawl` для извлечения URL параллельно, не запрашивая один и тот же URL дважды.

_Подсказка_: вы можете кэшировать уже запрошенные URL в карте, но карты
не безопасны для использования в многопоточной среде!

.play concurrency/exercise-web-crawler.go

* Куда Go дальше...

#appengine: Вы можете начать с
#appengine: [[https://golang.org/dl/][установки Go]].

#appengine: Как только вы установили Go,
Официальная
[[https://golang.org/doc/][Документация Go]] это отличное место, чтобы
#appengine: продолжить.
начать. 
Она содержит описания, обучающие пособия, видео и т.д.

Чтобы узнать как организовывать и работать с кодом на Go, посмотрите [[https://www.youtube.com/watch?v=XCsL89YtqCs][этот скринкаст]] или прочтите [[https://golang.org/doc/code.html][Как писать код на Go]].

Если вам нужна помощь по стандартной библиотеке, смотрите [[https://golang.org/pkg/][справочник по пакетам]]. Если нужна помощь по самому языку, то вы можете быть удивлены узнав, что [[https://golang.org/ref/spec][спецификация языка]] довольно удобна для чтения.

Для дальнейшего изучения многопоточной модели Go, посмотрите
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Шаблоны многопоточности в Go]]
([[https://talks.golang.org/2012/concurrency.slide][слайды]])
и
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Продвинутые шаблоны многопоточности в Go]]
([[https://talks.golang.org/2013/advconc.slide][слайды]])
, и почитайте
[[https://golang.org/doc/codewalk/sharemem/][Разделяйте память путем коммуникации]].

Чтобы начать писать веб-приложения, посмотрите
[[https://vimeo.com/53221558][Простая среда программирования]]
([[https://talks.golang.org/2012/simple.slide][слайды]])
и прочтите
[[https://golang.org/doc/articles/wiki/][Написание веб-приложений]].

[[https://golang.org/doc/codewalk/functions/][Функции первого класса в Go]] дает интересное представление о функциях в Go.

[[https://blog.golang.org/][Блог Go]] имеет большой архив полезных статей о Go.

Посетите [[https://golang.org][golang.org]] для дальнейшей информации.

